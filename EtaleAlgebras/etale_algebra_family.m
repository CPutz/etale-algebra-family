/*
 * Isomorphism classes of families of etale algebras parametrized by one variable.
 */

declare verbose AlgEtFam, 2;

import "utils.m" : zip, prod;
Q := Rationals();

intrinsic EtaleAlgebraFamily(F::RngUPolElt[RngUPol[FldRat]], p::RngIntElt
	: D := LocalFieldDatabase(),
	  Precision := 50,
	  Hint := [],
	  ParameterSpace := pAdicNbhdSpace(Rationals(), p),
	  BoundMethod := "Default") -> SeqEnum
{For F in Q[s][t], computes all isomorphism classes of etale algebras over Q_p
generated by F when s is specialized to all value in OK_p for which F(s,t) is separable.
A database of local fields D can be provided for faster searching of the etale algebras
and a list of possible etale algebras to try first can be provided using the parameter Hint.
All computations will be performed with the provided Precision (default 50). As an
additional restriction, s can be restricted to have valuation >= MinVal using the
corresponding parameter, and if CongrVal is set the value of c in Z/mZ then only values of
s with v(s) = c (mod m) will be considered. The parameter BoundMethod decides which
bound for Hensels lemma is used during the computations (this can greatly improve
computation times). Options for BoundMethod are Default, Separant, Derivative and
Difference.}

	R := Parent(F);
	S := BaseRing(R);
	Q := BaseRing(S);

	Qnf := RationalsAsNumberField();
	QtoQnf := Coercion(Q, Qnf);
	Snf,StoSnf := ChangeRing(S, Qnf, QtoQnf);
	Rnf,RtoRnf := ChangeRing(R, Snf, StoSnf);

	pl := Decomposition(Qnf, p)[1,1];

	return EtaleAlgebraFamily(RtoRnf(F), pl
		: D := D, Precision := Precision, Hint := Hint,
		  BoundMethod := BoundMethod, ParameterSpace := ParameterSpace);
end intrinsic;


intrinsic EtaleAlgebraFamily(F::RngUPolElt[RngUPol[FldNum]], p::PlcNumElt
	: D := LocalFieldDatabase(),
	  Precision := 50,
	  Hint := [],
	  ParameterSpace := pAdicNbhdSpace(BaseRing(Parent(F)), p),
	  BoundMethod := "Default") -> SeqEnum
{For F in K[s][t], computes all isomorphism classes of etale algebras over K_p
generated by F when s is specialized to all value in OK_p for which F(s,t) is separable.
A database of local fields D can be provided for faster searching of the etale algebras
and a list of possible etale algebras to try first can be provided using the parameter Hint.
All computations will be performed with the provided Precision (default 50). As an
additional restriction, s can be restricted to have valuation >= MinVal using the
corresponding parameter, and if CongrVal is set the value of c in Z/mZ then only values of
s with v(s) = c (mod m) will be considered. The parameter BoundMethod decides which
bound for Hensels lemma is used during the computations (this can greatly improve
computation times). Options for BoundMethod are Default, Separant, Derivative and
Difference.}
	require Valuation(Prime(ParameterSpace), p) gt 0: "Parameter space must be completed at a prime divisible by p";
	error if Degree(LeadingCoefficient(F)) ne 0, "Not implemented for polynomials with non-constant leading term"; 
	F /:= Evaluate(LeadingCoefficient(F),0);

	R := Parent(F);
	S := BaseRing(R);
	t := R.1;
	s := S.1;

	K := BaseRing(S);
	OK := Integers(K);
	pi := UniformizingElement(p);

	//set up completions (exact and non-exact)
	Kp,phi := Completion(K,p : Precision := Precision);
	OKp := Integers(Kp);
	piKp := UniformizingElement(Kp);
	Sp,StoSp := ChangeRing(S, Kp, phi);
	Rp,RtoRp := ChangeRing(R, Sp, StoSp);
	OKp_ex := quo<OKp | piKp^Precision>; //exact version of O_Kp
	ROKp_ex := PolynomialRing(OKp_ex);

	/*piPar := UniformizingElement(ParameterSpace);
	vpi := Valuation(Kp!piPar);
	ParameterSpaceEx := quo<Integers(ParameterSpace) | piPar^Precision>;
	piParEx := UniformizingElement(ParameterSpaceEx);
	X := pAdicNbhds(ParameterSpaceEx);*/
	B := AmbientSpace(ParameterSpace);
	pi_Par := UniformizingElement(ParameterSpace);
	vpi_Par := Valuation(pi_Par, p);

	// Make F monic and integral
	lc := LeadingCoefficient(LeadingCoefficient(F));
	vlc := Valuation(lc, p);
	F *:= pi^(-vlc);
	while exists {cs : cs in Coefficients(ct), ct in Coefficients(F) | Valuation(cs, p) lt 0} do
		F := pi^Degree(F) * Evaluate(F, t/pi);
	end while;

	vprintf AlgEtFam,1: "computing discriminant";
	disc := Discriminant(F);

	//TODO: make this obsolete
	min_val := MinValuation(ParameterSpace) * vpi_Par;

	rootsK  := [r : r in Roots(disc, K) | Valuation(r[1],p) ge min_val];
	//We assume that all integral roots of the discriminant over K_p are defined over K
	disc0 := disc div prod([(s - r[1])^r[2] : r in rootsK]);
	roots0Kp := [r[1] : r in Roots(StoSp(disc0),Kp) | Valuation(r[1]) ge min_val];
	require IsEmpty(roots0Kp): "The integral roots of the discriminant over K_p should be defined over K";

	vprintf AlgEtFam,1: ", roots = {";
	if not IsEmpty(rootsK) then vprintf AlgEtFam,1: "%o", rootsK[1,1]; end if;
	for r in rootsK[2..#rootsK] do
		vprintf AlgEtFam,1: ", %o", r[1];
	end for;
	vprintf AlgEtFam,1: "}\n";

	Nbhds_disc := []; // The neighborhoods around the roots of the discriminant
	Nbhds_oo := [];

	for r in rootsK do
		// Evaluate F(s,t) at s = r
		f := StoSp(Evaluate(SwitchVariables(F), r[1]));
		// The coefficient of s in F
		g := StoSp(Coefficient(SwitchVariables(F), 1));
		require g ne 0: "F must have a linear term in s";
		assert Degree(f) eq Degree(F);

		fac,cons := Factorization(f);
		//assert cons eq 1;
		fs := [<fi[1],fi[2]> : fi in fac];
		if #fs eq 1 then
			f_hats := [f div fi[1]^fi[2] : fi in fs];
		else
			f_hats := [&*[fs[i,1] ^ fs[i,2] : i in [1..#fs] | i ne j] : j in [1..#fs]];
		end if;

		c,cs := XGCD(f_hats);
		min_val_ci := Min([Valuation(ci) : ci in Coefficients(c), c in cs] cat [0]);
		c := c * phi(pi)^(-min_val_ci);
		cs := [phi(pi)^(-min_val_ci) * c : c in cs];

		//assert that sum_i cs[i] * f_hats[i] = c
		assert forall {co : co in Coefficients(c - &+[fc[1]*fc[2] : fc in zip(cs, f_hats)]) | OKp_ex!co eq 0};
		
		assert Degree(c) eq 0;
		c := ConstantCoefficient(c);

		rs := [(cf[1] * g) mod (cf[2][1]^cf[2][2]) : cf in zip(cs, fs)];

		vprintf AlgEtFam,1: "Computed standard form with c = %o\n", c;

		//initialize bound
		bound := 0;

		for i := 1 to #fs do
			fi := fs[i][1];
			ki := fs[i][2];
			ri := rs[i];
			Fi := SwitchVariables(fi^ki - RtoRp(t)*ri);

			vprintf AlgEtFam,2: "\nFactor %o = %o\n", i, Fi;
			//TODO: these discriminant and separant computations crash magma if Fi is not exact (i.e. in ROKpq)
			//TODO: if the Precision is too low, the stability bound may become infinite. Try to detect when this happens
			stab_i,mu_tau_i := StandardConditions(ROKp_ex!fi, ROKp_ex!ri, ki);
			bound := Max(bound, Valuation(c) + stab_i);
			vprintf AlgEtFam,2: "Stability bound = %o\n", stab_i;

			fi_hat := f_hats[i];
			res_i := Resultant(fi, fi_hat);
			vprintf AlgEtFam,2: "Resultant bound = %o\n", ki * mu_tau_i + Valuation(res_i) * ki / Degree(fi);
			bound := Max(bound, Valuation(c) + ki * mu_tau_i + Valuation(res_i) * ki / Degree(fi));

			for j := 1 to #fs do
				if i ne j then
					fi := fs[i][1];
					fj := fs[j][1];
					res_ij := Resultant(fi, fj);
					ki := fs[i][2];
					kj := fs[j][2];
					res_boundij := ki * kj * Valuation(res_ij);
					bound := Max(bound, Valuation(c) + res_boundij);

					vprintf AlgEtFam,2: "Resultant bound for (%o,%o) = %o\n", i, j, res_boundij;
				end if;
			end for;
		end for;
		vprintf AlgEtFam,2: "\n";

		vprintf AlgEtFam,1: "around %o: bound = %o\n", r[1], bound;
		bound := Floor(bound + 1);

		Append(~Nbhds_disc, pAdicNbhd(ParameterSpace, B!r[1], pi_Par^Ceiling(bound / vpi_Par), 1));

		k := LCM([fi[2] : fi in fs]);
		vprintf AlgEtFam,1: "around %o: common ramification index = %o\n", r[1], k;
		v := Ceiling(k * Ceiling(bound / k) / vpi_Par);
		
		if Type(B) eq FldRat then
			pB := Prime(ParameterSpace);
		else
			pB := Ideal(Prime(ParameterSpace));
		end if;
		// The group B_p*/(B_p*)^k (where B_p is the ambient space of the parameter space)
		KmKk,phik := pSelmerGroup(k, {pB});

		Nbhds_oo cat:= [pAdicNbhd(ParameterSpace, B!r[1], (a@@phik) * pi_Par^v, k) : a in KmKk];
	end for;

	vprintf AlgEtFam,1: "subdividing nbhds\n";
	min_val_s := Min([Valuation(cs,p) : cs in Coefficients(ct - Evaluate(ct, 0)), ct in Coefficients(F)]) / vpi_Par;

	//if K = Q then separant computations will be performed over Q instead of
	//RationalsAsNumberField because it is significantly faster
	if Degree(K) eq 1 then
		KtoQ := Coercion(K, Q);
		SQ,StoSQ := ChangeRing(S, Q, KtoQ);
		RQ,RtoRQ := ChangeRing(R, SQ, StoSQ);
		Fcomp := RtoRQ(F);
		if BoundMethod eq "Default" then
			BoundMethod := "Separant";
		end if;
	else
		Fcomp := F;
		if BoundMethod eq "Default" then
			BoundMethod := "Difference";
		end if;
	end if;

	case BoundMethod:
		when "Separant":
			vprintf AlgEtFam,1: "computing general separant\n";
			gen_bound := SwitchVariables(SeparantUPol(Fcomp) div Parent(F).1^Degree(F));
		when "Derivative":
			vprintf AlgEtFam,1: "computing general derivative evaluated at roots\n";
			gen_bound := SwitchVariables(ValuationsInRootsOfUPol(Derivative(F), F));
		when "Difference":
			vprintf AlgEtFam,1: "computing general derivative evaluated at roots\n";
			gen_bound := SwitchVariables(ValuationsInRootsOfUPol(Derivative(F), F));
			vprintf AlgEtFam,1: "computing general difference of roots\n";
			Re<e> := PolynomialRing(S);
			Rx<x> := PolynomialRing(Re);
			_<y> := PolynomialRing(Rx);
			gen_diff := SwitchVariables(Resultant(Resultant(e - (x-y), Evaluate(F,y)), Evaluate(F,x)) div e^Degree(F));
		else:
			error "Option for BoundMethod not supported:", BoundMethod;
	end case;

	// Subdivide in smaller stable neighborhoods
	Nbhds := [pAdicNbhd(ParameterSpace, 0, 1, 1)]; // The set containing O_K
	Nbhds_end := []; // The neighborhoods that do not contain a root of the discriminant

	depth := 0;
	repeat
		Nbhds_new := [];
		depth +:= 1;
		vprintf AlgEtFam,2: "subdivision %o with %o neighbourhoods\n", depth, #Nbhds;
		for N in Nbhds do
			if exists { Nd : Nd in Nbhds_disc | Nd subset N } then
				rad := Valuation(Radius(N),Prime(ParameterSpace));
				Nbhds_new cat:= Subdivide(N, rad + 1);
			elif exists { Nd : Nd in Nbhds_disc | N subset Nd } then
				//do nothing since Np is contained in one of the neighborhoods around a root of the discriminant
			else
				rep := Representative(N);
				sN := Evaluate(gen_bound, rep);
				bN := Max([r[1] : r in ValuationsOfRoots(sN,Ideal(p))]) / vpi_Par;
				case BoundMethod:
					when "Separant":
						boundN := bN;
					when "Derivative":
						boundN := 2*bN;
					when "Difference":
						dN := Evaluate(gen_diff, rep);
						bdN := Max([r[1] : r in ValuationsOfRoots(dN,Ideal(p))]) / vpi_Par;
						boundN := bN + bdN;
				end case;

				rad := Valuation(Radius(N),Prime(ParameterSpace));
				if boundN - min_val_s lt rad then
					Append(~Nbhds_end, N);
				else
					Nbhds_new cat:= Subdivide(N, Floor(boundN - min_val_s + 1));
				end if;
			end if;
		end for;
		Nbhds := Nbhds_new;

		// Filter neighbourhoods
		Nbhds := [N : N in Nbhds | not IsEmpty(N)];
	until IsEmpty(Nbhds);

	// Add neighborhoods around the roots of the discriminant
	Nbhds := Nbhds_oo cat Nbhds_end;

	// Filter neighborhoods
	Nbhds := [N : N in Nbhds | not IsEmpty(N)];

	vprintf AlgEtFam,1: "computing isomorphism classes of %o etale algebras\n", #Nbhds;
	//use finite precision for last step
	KpP := ChangePrecision(Kp, Precision);
	psi := Coercion(Kp, KpP);
	SpP,StoSpP := ChangeRing(S, KpP, phi * psi);
	RpP,RtoRpP := ChangeRing(R, SpP, StoSpP);

	E := FindIsomorphismClasses([Evaluate(SwitchVariables(RtoRpP(F)),OKp_ex!Kp!B!Representative(N)) : N in Nbhds] :
		Data := Nbhds, Hint := Hint);
	vprintf AlgEtFam,1: "%o isomorphism classes found among %o etale algebras\n", #E, #Nbhds;

	return E;
end intrinsic;


intrinsic StandardConditions(f::RngUPolElt, g::RngUPolElt, k::RngIntElt) -> RngIntElt, RngElt
{The standard conditions for f^k - sg (Definition ?)}
	require Valuation(LeadingCoefficient(f)) eq 0: "f must be monic";
	require Degree(g) le k * Degree(f): "Must have deg(g) le deg(f^k)";

	R := Parent(f);
	K := BaseRing(R);
	n := k * Degree(f);

	df := Derivative(f);
	mu_f := MaxValuationInRootsOf(df,f);
	tau_F := Valuation(K!k) + Valuation(Resultant(f,g)) * (k - 1) / n;

	sigfg := Separant(f,g);

	return Max([2 * k * (mu_f + tau_F), k * sigfg]), mu_f + tau_F;
end intrinsic;


intrinsic StandardConditions(f::RngUPolElt, g::RngUPolElt, k::RngIntElt, p::PlcNumElt) -> RngIntElt, RngElt
{The standard conditions for f^k - sg (Definition ?), at the prime p.}
	require Valuation(LeadingCoefficient(f),p) eq 0: "f must be monic";
	require Degree(g) le k * Degree(f): "Must have deg(g) le deg(f^k)";

	R := Parent(f);
	K := BaseRing(R);
	n := k * Degree(f);

	df := Derivative(f);
	mu_f := MaxValuationInRootsOf(df,f,p);
	tau_F := Valuation(K!k,p) + Valuation(Resultant(f,g),p) * (k - 1) / n;

	sigfg := Separant(f,g,p);

	return Max([2 * k * (mu_f + tau_F), k * sigfg]), mu_f + tau_F;
end intrinsic;
