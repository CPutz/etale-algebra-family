/*
 * Isomorphism classes of families of etale algebras parametrized by one variable.
 */

declare verbose AlgEtFam, 2;

import "utils.m" : zip, prod;
Q := Rationals();

intrinsic EtaleAlgebraFamily(F::RngUPolElt[RngUPol[FldRat]], p::RngIntElt
	: D := LocalFieldDatabase(),
	  Hint := [],
	  Precision := 50,
	  CongrVal := Integers(1)!0,
	  MinVal := 0,
	  ParameterSpace := pAdicField(p,Precision),
	  BoundMethod := "Default") -> SeqEnum
{For F in Q[s][t], computes all isomorphism classes of etale algebras over Q_p
generated by F when s is specialized to all value in OK_p for which F(s,t) is separable.
A database of local fields D can be provided for faster searching of the etale algebras
and a list of possible etale algebras to try first can be provided using the parameter Hint.
All computations will be performed with the provided Precision (default 50). As an
additional restriction, s can be restricted to have valuation >= MinVal using the
corresponding parameter, and if CongrVal is set the value of c in Z/mZ then only values of
s with v(s) = c (mod m) will be considered. The parameter BoundMethod decides which
bound for Hensels lemma is used during the computations (this can greatly improve
computation times). Options for BoundMethod are Default, Separant, Derivative and
Difference.}

	R := Parent(F);
	S := BaseRing(R);
	Q := BaseRing(S);

	Qnf := RationalsAsNumberField();
	QtoQnf := Coercion(Q, Qnf);
	Snf,StoSnf := ChangeRing(S, Qnf, QtoQnf);
	Rnf,RtoRnf := ChangeRing(R, Snf, StoSnf);

	pl := Decomposition(Qnf, p)[1,1];

	return EtaleAlgebraFamily(RtoRnf(F), pl
		: D := D, Precision := Precision, CongrVal := CongrVal, MinVal := MinVal,
			Hint := Hint, BoundMethod := BoundMethod, ParameterSpace := ParameterSpace);
end intrinsic;


intrinsic EtaleAlgebraFamily(F::RngUPolElt[RngUPol[FldNum]], p::PlcNumElt
	: D := LocalFieldDatabase(),
	  Precision := 50,
	  CongrVal := Integers(1)!0,
	  MinVal := 0,
	  Hint := [],
	  ParameterSpace := false,
	  BoundMethod := "Default") -> SeqEnum
{For F in K[s][t], computes all isomorphism classes of etale algebras over K_p
generated by F when s is specialized to all value in OK_p for which F(s,t) is separable.
A database of local fields D can be provided for faster searching of the etale algebras
and a list of possible etale algebras to try first can be provided using the parameter Hint.
All computations will be performed with the provided Precision (default 50). As an
additional restriction, s can be restricted to have valuation >= MinVal using the
corresponding parameter, and if CongrVal is set the value of c in Z/mZ then only values of
s with v(s) = c (mod m) will be considered. The parameter BoundMethod decides which
bound for Hensels lemma is used during the computations (this can greatly improve
computation times). Options for BoundMethod are Default, Separant, Derivative and
Difference.}
	error if Degree(LeadingCoefficient(F)) ne 0, "Not implemented for polynomials with non-constant leading term"; 
	F /:= Evaluate(LeadingCoefficient(F),0);

	R := Parent(F);
	S := BaseRing(R);
	t := R.1;
	s := S.1;

	K := BaseRing(S);
	OK := Integers(K);
	pi := UniformizingElement(p);


	Kp,phi := Completion(K,p : Precision := Precision);
	OKp := Integers(Kp);
	piKp := UniformizingElement(Kp);
	Sp,StoSp := ChangeRing(S, Kp, phi);
	Rp,RtoRp := ChangeRing(R, Sp, StoSp);
	OKp_ex := quo<OKp | piKp^Precision>; //exact version of O_Kp
	ROKpq := PolynomialRing(OKpq);

	if ParameterSpace cmpeq false then
		ParameterSpace := hom<K -> K | >; //the identity map from K to K
	end if;

	//ParameterSpace := BaseField(BaseField(Kp));
	//ParameterSpace;
	piPar := UniformizingElement(ParameterSpace);
	vpi := Valuation(Kp!piPar);
	ParameterSpaceEx := quo<Integers(ParameterSpace) | piPar^Precision>;
	piParEx := UniformizingElement(ParameterSpaceEx);
	X := pAdicNbhds(ParameterSpaceEx);

	// Make F monic and integral
	lc := LeadingCoefficient(LeadingCoefficient(F));
	vlc := Valuation(lc, p);
	F *:= pi^(-vlc);
	while exists {cs : cs in Coefficients(ct), ct in Coefficients(F) | Valuation(cs, p) lt 0} do
		F := pi^Degree(F) * Evaluate(F, t/pi);
	end while;

	vprintf AlgEtFam,1: "computing discriminant";
	disc := Discriminant(F);

	rootsK  := [r : r in Roots(disc, K) | Valuation(r[1],p) ge MinVal * vpi];
	//We assume that all integral roots of the discriminant over K_p are defined over K
	disc0 := disc div prod([(s - r[1])^r[2] : r in rootsK]);
	roots0Kp := [r[1] : r in Roots(StoSp(disc0),Kp) | Valuation(r[1]) ge MinVal * vpi];
	require IsEmpty(roots0Kp): "The integral roots of the discriminant over K_p should be defined over K";

	vprintf AlgEtFam,1: ", roots = {";
	if not IsEmpty(rootsK) then vprintf AlgEtFam,1: "%o", rootsK[1,1]; end if;
	for r in rootsK[2..#rootsK] do
		vprintf AlgEtFam,1: ", %o", r[1];
	end for;
	vprintf AlgEtFam,1: "}\n";

	Nbhds_disc := []; // The neighborhoods around the roots of the discriminant
	Nbhds_oo := [];

	for r in rootsK do
		// Evaluate F(s,t) at s = r
		f := StoSp(Evaluate(SwitchVariables(F), r[1]));
		// The coefficient of s in F
		g := StoSp(Coefficient(SwitchVariables(F), 1));
		require g ne 0: "F must have a linear term in s";
		assert Degree(f) eq Degree(F);

		fac,cons := Factorization(f);
		//assert cons eq 1;
		fs := [<fi[1],fi[2]> : fi in fac];
		//f_hats := [f div fi[1]^fi[2] : fi in fs];
		if #fs eq 1 then
			f_hats := [f div fi[1]^fi[2] : fi in fs];
		else
			f_hats := [&*[fs[i,1] ^ fs[i,2] : i in [1..#fs] | i ne j] : j in [1..#fs]];
		end if;

		c,cs := XGCD(f_hats);
		min_val_ci := Min([Valuation(ci) : ci in Coefficients(c), c in cs] cat [0]);
		c := c * phi(pi)^(-min_val_ci);
		cs := [phi(pi)^(-min_val_ci) * c : c in cs];

		//assert that sum_i cs[i] * f_hats[i] = c
		assert forall {co : co in Coefficients(c - &+[fc[1]*fc[2] : fc in zip(cs, f_hats)]) | OKpq!co eq 0};
		
		assert Degree(c) eq 0;
		c := ConstantCoefficient(c);

		rs := [(cf[1] * g) mod (cf[2][1]^cf[2][2]) : cf in zip(cs, fs)];

		vprintf AlgEtFam,1: "Computed standard form with c = %o\n", c;

		//initialize bound
		bound := 0;

		for i := 1 to #fs do
			fi := fs[i][1];
			ki := fs[i][2];
			ri := rs[i];
			Fi := SwitchVariables(fi^ki - RtoRp(t)*ri);

			vprintf AlgEtFam,2: "\nFactor %o = %o\n", i, Fi;
			//TODO: these discriminant and separant computations crash magma if Fi is not exact (i.e. in ROKpq)
			//TODO: if the Precision is too low, the stability bound may become infinite
			stab_i,mu_tau_i := StandardConditions(ROKpq!fi, ROKpq!ri, ki);
			bound := Max(bound, Valuation(c) + stab_i);
			vprintf AlgEtFam,2: "Stability bound = %o\n", stab_i;

			fi_hat := f_hats[i];
			res_i := Resultant(fi, fi_hat);
			vprintf AlgEtFam,2: "Resultant bound = %o\n", ki * mu_tau_i + Valuation(res_i) * ki / Degree(fi);
			bound := Max(bound, Valuation(c) + ki * mu_tau_i + Valuation(res_i) * ki / Degree(fi));

			for j := 1 to #fs do
				if i ne j then
					fi := fs[i][1];
					fj := fs[j][1];
					res_ij := Resultant(fi, fj);
					ki := fs[i][2];
					kj := fs[j][2];
					res_boundij := ki * kj * Valuation(res_ij);
					bound := Max(bound, Valuation(c) + res_boundij);

					vprintf AlgEtFam,2: "Resultant bound for (%o,%o) = %o\n", i, j, res_boundij;
				end if;
			end for;
		end for;
		vprintf AlgEtFam,2: "\n";

		vprintf AlgEtFam,1: "around %o: bound = %o\n", r[1], bound;
		bound := Floor(bound + 1);

		Append(~Nbhds_disc, ParameterSpace!phi(r[1]) + O(piPar^Floor(bound / vpi)));

		k := LCM([fi[2] : fi in fs]);
		vprintf AlgEtFam,1: "around %o: common ramification index = %o\n", r[1], k;
		v := Ceiling(k * Ceiling(bound / k) / vpi);

		//the group K*/(K*)^k
		//KmKk,phik := pSelmerGroup(k,Kp);
		//KmKk,phik := pSelmerGroup(k,pAdicField(7,500));
		KmKk,phik := pSelmerGroup(k,ParameterSpace);

		//psi := Coercion(ParameterSpace, Kp);
		//Nbhds_oo cat:= [pAdicNbhd(X, OKpq!r[1], (OKpq!(psi(a@@phik))) * piOKpq^v, k) : a in KmKk];
		Nbhds_oo cat:= [pAdicNbhd(X, ParameterSpaceEx!r[1], (ParameterSpaceEx!(a@@phik)) * piParEx^v, k) : a in KmKk];
	end for;

	vprintf AlgEtFam,1: "subdividing nbhds\n";
	min_val_s := Min([Valuation(cs,p) : cs in Coefficients(ct - Evaluate(ct, 0)), ct in Coefficients(F)]) / vpi;

	//if K = Q then separant computations will be performed over Q instead of
	//RationalsAsNumberField because it is significantly faster
	if Degree(K) eq 1 then
		KtoQ := Coercion(K, Q);
		SQ,StoSQ := ChangeRing(S, Q, KtoQ);
		RQ,RtoRQ := ChangeRing(R, SQ, StoSQ);
		Fcomp := RtoRQ(F);
		if BoundMethod eq "Default" then
			BoundMethod := "Separant";
		end if;
	else
		Fcomp := F;
		if BoundMethod eq "Default" then
			BoundMethod := "Difference";
		end if;
	end if;

	case BoundMethod:
		when "Separant":
			vprintf AlgEtFam,1: "computing general separant\n";
			gen_bound := SwitchVariables(SeparantUPol(Fcomp) div Parent(F).1^Degree(F));
		when "Derivative":
			vprintf AlgEtFam,1: "computing general derivative evaluated at roots\n";
			gen_bound := SwitchVariables(ValuationsInRootsOfUPol(Derivative(F), F));
		when "Difference":
			vprintf AlgEtFam,1: "computing general derivative evaluated at roots\n";
			gen_bound := SwitchVariables(ValuationsInRootsOfUPol(Derivative(F), F));
			vprintf AlgEtFam,1: "computing general difference of roots\n";
			Re<e> := PolynomialRing(S);
			Rx<x> := PolynomialRing(Re);
			_<y> := PolynomialRing(Rx);
			gen_diff := SwitchVariables(Resultant(Resultant(e - (x-y), Evaluate(F,y)), Evaluate(F,x)) div e^Degree(F));
		else:
			error "Option for BoundMethod not supported:", BoundMethod;
	end case;

	// Subdivide in smaller stable neighborhoods
	Nbhds := [<Integers(ParameterSpace)!0,0>];

	Nbhds_end := []; // The neighborhoods that do not contain a root of the discriminant
	depth := 0;

	repeat
		Nbhds_new := [];
		depth +:= 1;
		vprintf AlgEtFam,2: "subdivision %o with %o neighbourhoods\n", depth, #Nbhds;
		for N in Nbhds do
			Np := N[1] + O(piPar^N[2]);
			error if N[2] ge Precision, "Precision too low:", Precision;

			if exists { Nd : Nd in Nbhds_disc | ContainedIn(Nd, Np) } then
				Nbhds_new cat:= Subdivide(N[1], N[2], N[2] + 1);
			elif exists { Nd : Nd in Nbhds_disc | ContainedIn(Np, Nd) } then
				//do nothing since Np is contained in one of the neighborhoods around a root of the discriminant
			else
				rep := N[1]@@phi;
				sN := Evaluate(gen_bound, rep);
				bN := Max([r[1] : r in ValuationsOfRoots(sN,Ideal(p))]) / vpi;
				case BoundMethod:
					when "Separant":
						boundN := bN;
					when "Derivative":
						boundN := 2*bN;
					when "Difference":
						dN := Evaluate(gen_diff, rep);
						bdN := Max([r[1] : r in ValuationsOfRoots(dN,Ideal(p))]) / vpi;
						boundN := bN + bdN;
				end case;

				if boundN - min_val_s lt N[2] then
					Append(~Nbhds_end, N);
				else
					Nbhds_new cat:= Subdivide(N[1], N[2], Floor(boundN - min_val_s + 1));
				end if;
			end if;
		end for;
		Nbhds := Nbhds_new;

		// Filter neighbourhoods
		Nbhds := [N : N in Nbhds | ContainsElementOfValuation(pAdicNbhd(X, ParameterSpaceEx!N[1], piParEx^N[2], 1), CongrVal, MinVal)];
	until IsEmpty(Nbhds);

	// Add neighborhoods around the roots of the discriminant
	Nbhds := Nbhds_oo cat [pAdicNbhd(X, ParameterSpaceEx!N[1], piParEx^N[2], 1) : N in Nbhds_end];

	// Filter neighborhoods
	Nbhds := [N : N in Nbhds | ContainsElementOfValuation(N, CongrVal, MinVal)];

	vprintf AlgEtFam,1: "computing isomorphism classes of %o etale algebras\n", #Nbhds;
	//use finite precision for last step
	KpP := ChangePrecision(Kp, Precision);
	psi := Coercion(Kp, KpP);
	SpP,StoSpP := ChangeRing(S, KpP, phi * psi);
	RpP,RtoRpP := ChangeRing(R, SpP, StoSpP);

	E := FindIsomorphismClasses([Evaluate(SwitchVariables(RtoRpP(F)),OKpq!Kp!ParameterSpace!Representative(N)) : N in Nbhds] :
		Data := Nbhds, Hint := Hint);
	vprintf AlgEtFam,1: "%o isomorphism classes found among %o etale algebras\n", #E, #Nbhds;

	return E;
end intrinsic;


intrinsic StandardConditions(f::RngUPolElt, g::RngUPolElt, k::RngIntElt) -> RngIntElt, RngElt
{The standard conditions for f^k - sg (Definition ?)}
	require Valuation(LeadingCoefficient(f)) eq 0: "f must be monic";
	require Degree(g) le k * Degree(f): "Must have deg(g) le deg(f^k)";

	R := Parent(f);
	K := BaseRing(R);
	n := k * Degree(f);

	df := Derivative(f);
	mu_f := MaxValuationInRootsOf(df,f);
	tau_F := Valuation(K!k) + Valuation(Resultant(f,g)) * (k - 1) / n;

	sigfg := Separant(f,g);

	return Max([2 * k * (mu_f + tau_F), k * sigfg]), mu_f + tau_F;
end intrinsic;


intrinsic StandardConditions(f::RngUPolElt, g::RngUPolElt, k::RngIntElt, p::PlcNumElt) -> RngIntElt, RngElt
{The standard conditions for f^k - sg (Definition ?), at the prime p.}
	require Valuation(LeadingCoefficient(f),p) eq 0: "f must be monic";
	require Degree(g) le k * Degree(f): "Must have deg(g) le deg(f^k)";

	R := Parent(f);
	K := BaseRing(R);
	n := k * Degree(f);

	df := Derivative(f);
	mu_f := MaxValuationInRootsOf(df,f,p);
	tau_F := Valuation(K!k,p) + Valuation(Resultant(f,g),p) * (k - 1) / n;

	sigfg := Separant(f,g,p);

	return Max([2 * k * (mu_f + tau_F), k * sigfg]), mu_f + tau_F;
end intrinsic;
