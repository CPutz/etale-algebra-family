// Load this file from the main folder
AttachSpec("spec");


function splitting_partition(E);
	return {* Degree(C[1],BaseRing(E)) ^^ C[2] : C in ComponentsIsoStructure(E) *};
end function;

// generates all subpartitions of p
function subpartitions(p);
	C := CartesianProduct([Partitions(r) : r in p]);
	return SetToSequence({@ {* r : r in ci, ci in c *} : c in C @});
end function;


printf "\n==================================================================\n";
printf "We perform the computations from Proposition ?.\n";
printf "==================================================================\n\n";

load "misc/scripts/257/upperbounds.m";

E2 := [ E : E in U2 |
	splitting_partition(E) in subpartitions([7,1]) ];

printf "Possible local algebra(s) at 2: %o\n", E2;
printf "Valuation of possible local discriminants at 2: %o\n",
	{ Valuation(Discriminant(E)) : E in E2 };

E5 := [ E : E in U5 |
	splitting_partition(E) in subpartitions([7,1]) ];

printf "Valuation of possible local discriminants at 5: %o\n",
	{ Valuation(Discriminant(E)) : E in E5 };

E7 := [ E : E in U7 |
	splitting_partition(E) in subpartitions([7,1]) ];

printf "Valuation of possible local discriminants at 7: %o\n",
	{ Valuation(Discriminant(E)) : E in E7 };


// A hunter search shows that the only septic number fields satisfying all
// local conditions, is Q(5^(1/7))

printf "\n==================================================================\n";
printf "We perform the computations from Proposition ?.\n";
printf "==================================================================\n\n";

load "misc/scripts/257/covering.m";

QQ := Rationals();
_<x> := PolynomialRing(QQ);
L<a> := NumberField(x^7 - 5);

p1 := EtoE1(
	E(L)![4*a^6 - a^5 - 4*a^4 + 4*a^3 + 4*a^2 - 5*a + 6,
		-15*a^6 - 12*a^5 + 24*a^4 - 6*a^3 - 51*a^2 + 25*a + 55,
		1]);
p2 := EtoE1(
	E(L)![33*a^6 + 4*a^5 + 34*a^4 - 19*a^3 + 3*a^2 + 22*a - 9,
		119*a^6 - 28*a^5 + 56*a^4 - 91*a^3 + 77*a^2 + 154*a + 105,
		a^5 + 5*a^4 - 2*a^2 + a - 4]);
p3 :=EtoE1(
	E(L)![-42*a^6 - 21*a^5 + 77*a^4 - 98*a^2 + 91*a + 133,
		21*a^6 - 35*a^5 - 56*a^4 - 28*a^2 - 70*a + 70,
		8*a^6 + 2*a^5 - 20*a^4 + 24*a^2 - 19*a - 32]);

E1L := BaseChange(E1,L);

//time rank := RankBound(EL); //crashes
rank := 3;

gens := [p1,p2,p3];
//assert IsLinearlyIndependent(gens); //crashes
assert #gens eq rank;

//the subgroup generated by gens is now saturated at 2 and 3
gens := Saturation(Saturation([E1L!p : p in gens], 2), 3);

A := AbelianGroup([Order(g) : g in gens]);
AtoE1L := map< A -> E1L | x :-> &+[Eltseq(x)[i]*gens[i] : i in [1..#gens]] >;
PhiE1L := map< E1L -> P1 | DefiningEquations(PhiE1) >;

printf "Performing elliptic curve Chabauty\n";

time V,R := Chabauty(AtoE1L, PhiE1L : IndexBound := 6);
assert R lt Infinity();
assert PrimeDivisors(R) subset {2,3};

pts_E1L := { AtoE1L(v) : v in V };
printf "The points in E1(L) with rational image under Φ_E1 are %o\n", pts_E1L;

// In fact, all points in pts_E1L are already defined over Q
pts_E1 := { E1!p : p in pts_E1L };

pts_Csigma := {@ @};
for p in pts_E1 do
	S := Cluster(E1, p);
	pts_Csigma join:= RationalPoints(Pullback(CsigmatoE0 * E0toE1, S));
end for;
printf "The points in (C/σ)(L) with rational image under Φ are %o\n", pts_Csigma;

pts_C := {@ @};
for p in pts_Csigma do
	S := Cluster(Csigma, p);
	pts_C join:= RationalPoints(Pullback(CtoCsigma, S));
end for;
printf "The points in C(L) with rational image under ϕ are %o\n", pts_C;